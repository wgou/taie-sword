<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€å•é›†æˆç¤ºä¾‹</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; }
        button { padding: 10px 20px; margin: 5px; }
        input { padding: 8px; margin: 5px; width: 200px; }
        #messages { border: 1px solid #ccc; height: 200px; overflow-y: auto; padding: 10px; margin: 10px 0; }
        .status { padding: 5px; margin: 5px 0; font-weight: bold; }
        .connected { color: green; }
        .disconnected { color: red; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”Œ WebRTC ç®€å•é›†æˆç¤ºä¾‹</h1>
        
        <!-- è¿æ¥æ§åˆ¶ -->
        <div>
            <input type="text" id="room" placeholder="æˆ¿é—´ID" value="test123">
            <button onclick="connect()">è¿æ¥</button>
            <button onclick="disconnect()">æ–­å¼€</button>
        </div>
        
        <!-- çŠ¶æ€æ˜¾ç¤º -->
        <div id="status" class="status disconnected">çŠ¶æ€: æœªè¿æ¥</div>
        <div id="mode" class="status">æ¨¡å¼: æœªçŸ¥</div>
        
        <!-- æ¶ˆæ¯åŒºåŸŸ -->
        <div id="messages"></div>
        
        <!-- æ¶ˆæ¯å‘é€ -->
        <div>
            <input type="text" id="messageText" placeholder="è¾“å…¥æ¶ˆæ¯">
            <button onclick="sendMessage()">å‘é€</button>
        </div>
        
        <!-- æ–‡ä»¶å‘é€ -->
        <div>
            <input type="file" id="fileInput">
            <button onclick="sendFile()">å‘é€æ–‡ä»¶</button>
        </div>
        
        <!-- P2Pæ§åˆ¶ -->
        <div>
            <button onclick="initiateP2P()">å‘èµ·P2Pè¿æ¥</button>
            <button onclick="toggleAutoP2P()">åˆ‡æ¢è‡ªåŠ¨P2P</button>
        </div>
    </div>

    <!-- å¼•å…¥ WebRTC å®¢æˆ·ç«¯æ¨¡å— -->
    <script src="webrtc-client.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let webrtcClient = null;
        
        // åˆå§‹åŒ– WebRTC å®¢æˆ·ç«¯
        function initWebRTC() {
            webrtcClient = new WebRTCClient({
                serverUrl: 'ws://127.0.0.1:9001',
                debug: true,
                autoInitiateP2P: false, // é»˜è®¤æ‰‹åŠ¨æ§åˆ¶
                callbacks: {
                    onConnected: () => {
                        updateStatus('å·²è¿æ¥', 'connected');
                        addMessage('âœ… è¿æ¥æˆåŠŸ');
                    },
                    onDisconnected: () => {
                        updateStatus('æœªè¿æ¥', 'disconnected');
                        updateMode('æœªè¿æ¥');
                        addMessage('âŒ è¿æ¥æ–­å¼€');
                    },
                    onUserJoined: (userId) => {
                        addMessage(`ğŸ‘¤ ç”¨æˆ· ${userId} åŠ å…¥`);
                    },
                    onUserLeft: (userId) => {
                        addMessage(`ğŸ‘‹ ç”¨æˆ· ${userId} ç¦»å¼€`);
                    },
                    onMessageReceived: (sender, message, isP2P) => {
                        const type = isP2P ? 'ğŸ”— P2P' : 'ğŸŒ è½¬å‘';
                        addMessage(`${type} ${sender}: ${message}`);
                    },
                    onBinaryDataReceived: (sender, data, isP2P) => {
                        const type = isP2P ? 'ğŸ”— P2P' : 'ğŸŒ è½¬å‘';
                        const size = data.byteLength || data.size || 0;
                        addMessage(`${type} ${sender} å‘é€æ–‡ä»¶ (${formatSize(size)})`);
                    },
                    onConnectionStateChanged: (state) => {
                        updateMode(state);
                    },
                    onError: (error) => {
                        addMessage(`âŒ é”™è¯¯: ${error}`);
                    }
                }
            });
        }
        
        // è¿æ¥å‡½æ•°
        async function connect() {
            const roomId = document.getElementById('room').value.trim();
            if (!roomId) {
                alert('è¯·è¾“å…¥æˆ¿é—´ID');
                return;
            }
            
            if (!webrtcClient) {
                initWebRTC();
            }
            
            try {
                await webrtcClient.connect(roomId);
            } catch (error) {
                addMessage(`âŒ è¿æ¥å¤±è´¥: ${error.message}`);
            }
        }
        
        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (webrtcClient) {
                webrtcClient.disconnect();
            }
        }
        
        // å‘é€æ¶ˆæ¯
        function sendMessage() {
            const messageText = document.getElementById('messageText');
            const message = messageText.value.trim();
            
            if (!message || !webrtcClient) return;
            
            if (webrtcClient.sendMessage(message)) {
                addMessage(`ğŸ’¬ æˆ‘: ${message}`);
                messageText.value = '';
            } else {
                addMessage('âŒ æ¶ˆæ¯å‘é€å¤±è´¥');
            }
        }
        
        // å‘é€æ–‡ä»¶
        function sendFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            
            if (!file || !webrtcClient) return;
            
            if (webrtcClient.sendBinaryData(file)) {
                addMessage(`ğŸ“ æˆ‘å‘é€æ–‡ä»¶: ${file.name} (${formatSize(file.size)})`);
            } else {
                addMessage('âŒ æ–‡ä»¶å‘é€å¤±è´¥');
            }
        }
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatus(text, className) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `çŠ¶æ€: ${text}`;
            statusEl.className = `status ${className}`;
        }
        
        function updateMode(mode) {
            document.getElementById('mode').textContent = `æ¨¡å¼: ${mode}`;
        }
        
        // æ·»åŠ æ¶ˆæ¯åˆ°æ˜¾ç¤ºåŒºåŸŸ
        function addMessage(message) {
            const messagesEl = document.getElementById('messages');
            const time = new Date().toLocaleTimeString();
            const messageEl = document.createElement('div');
            messageEl.innerHTML = `<small>[${time}]</small> ${message}`;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }
        
        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }
        
        // å›è½¦å‘é€æ¶ˆæ¯
        document.getElementById('messageText').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // æ–°å¢P2Pæ§åˆ¶åŠŸèƒ½
        async function initiateP2P() {
            if (!webrtcClient || !webrtcClient.canInitiateP2P()) {
                addMessage('âŒ å½“å‰æ— æ³•å‘èµ·P2Pè¿æ¥');
                return;
            }
            
            addMessage('ğŸš€ æ‰‹åŠ¨å‘èµ·P2Pè¿æ¥...');
            const success = await webrtcClient.manualInitiateP2P();
            if (success) {
                addMessage('âœ… P2Pè¿æ¥å‘èµ·æˆåŠŸ');
            } else {
                addMessage('âŒ P2Pè¿æ¥å‘èµ·å¤±è´¥');
            }
        }
        
        function toggleAutoP2P() {
            if (!webrtcClient) return;
            
            const currentState = webrtcClient.getConnectionState().autoInitiateP2P;
            const newState = !currentState;
            webrtcClient.setAutoInitiateP2P(newState);
            addMessage(`ğŸ”§ è‡ªåŠ¨P2Pæ¨¡å¼: ${newState ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆæç¤º
        document.addEventListener('DOMContentLoaded', () => {
            addMessage('ğŸ“± é¡µé¢å·²åŠ è½½ï¼Œè¯·è¾“å…¥æˆ¿é—´IDå¹¶è¿æ¥');
            addMessage('ğŸ’¡ æç¤º: è¿æ¥åå¯ä»¥æ‰‹åŠ¨å‘èµ·P2Pè¿æ¥æˆ–å¯ç”¨è‡ªåŠ¨æ¨¡å¼');
        });
    </script>
</body>
</html>
