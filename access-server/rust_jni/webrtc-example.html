<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTCå®¢æˆ·ç«¯ä½¿ç”¨ç¤ºä¾‹</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .status {
            padding: 8px;
            border-radius: 4px;
            margin: 5px 0;
            font-weight: bold;
        }
        .status.connected { background: #d4edda; color: #155724; }
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .input-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        input[type="text"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            padding: 8px 16px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .messages {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin: 10px 0;
            background: #fafafa;
        }
        .debug-info {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ WebRTCå®¢æˆ·ç«¯ä½¿ç”¨ç¤ºä¾‹</h1>
        
        <div class="input-group">
            <input type="text" id="roomId" placeholder="æˆ¿é—´ID" value="room123">
            <button id="connectBtn">è¿æ¥</button>
            <button id="disconnectBtn" disabled>æ–­å¼€</button>
        </div>
        
        <div class="status disconnected" id="status">çŠ¶æ€: æœªè¿æ¥</div>
        <div class="status disconnected" id="chatMode">æ¨¡å¼: æœªè¿æ¥</div>
        
        <div class="messages" id="messages"></div>
        
        <div class="input-group">
            <input type="text" id="messageInput" placeholder="è¾“å…¥æ¶ˆæ¯..." disabled>
            <button id="sendBtn" disabled>å‘é€æ–‡æœ¬</button>
            <button id="debugBtn" disabled>è°ƒè¯•æ£€æŸ¥</button>
        </div>
        
        <div class="input-group">
            <button id="initiateP2PBtn" disabled>æ‰‹åŠ¨å‘èµ·P2P</button>
            <button id="reconnectP2PBtn" disabled>é‡æ–°è¿æ¥P2P</button>
            <button id="toggleAutoP2PBtn" disabled>åˆ‡æ¢è‡ªåŠ¨P2P</button>
            <button id="p2pDetailsBtn" disabled>P2Pè¯¦æƒ…</button>
        </div>
        
        <div class="input-group">
            <input type="file" id="fileInput" disabled>
            <button id="sendFileBtn" disabled>å‘é€æ–‡ä»¶</button>
        </div>
        
        <h3>è°ƒè¯•ä¿¡æ¯</h3>
        <div class="debug-info" id="debugInfo">ç­‰å¾…è¿æ¥...</div>
    </div>

    <!-- å¼•å…¥WebRTCå®¢æˆ·ç«¯æ¨¡å— -->
    <script src="webrtc-client.js"></script>
    
    <script>
        class WebRTCDemo {
            constructor() {
                this.webrtcClient = null;
                this.setupUI();
                this.initWebRTC();
            }
            
            setupUI() {
                // è·å–DOMå…ƒç´ 
                this.elements = {
                    roomId: document.getElementById('roomId'),
                    connectBtn: document.getElementById('connectBtn'),
                    disconnectBtn: document.getElementById('disconnectBtn'),
                    status: document.getElementById('status'),
                    chatMode: document.getElementById('chatMode'),
                    messages: document.getElementById('messages'),
                    messageInput: document.getElementById('messageInput'),
                    sendBtn: document.getElementById('sendBtn'),
                    debugBtn: document.getElementById('debugBtn'),
                    fileInput: document.getElementById('fileInput'),
                    sendFileBtn: document.getElementById('sendFileBtn'),
                    debugInfo: document.getElementById('debugInfo')
                };
                
                // ç»‘å®šäº‹ä»¶
                this.elements.connectBtn.addEventListener('click', () => this.connect());
                this.elements.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.elements.sendBtn.addEventListener('click', () => this.sendMessage());
                this.elements.debugBtn.addEventListener('click', () => this.runDebugCheck());
                this.elements.sendFileBtn.addEventListener('click', () => this.sendFile());
                
                // æ–°å¢çš„P2Pæ§åˆ¶æŒ‰é’®äº‹ä»¶
                document.getElementById('initiateP2PBtn').addEventListener('click', () => this.initiateP2P());
                document.getElementById('reconnectP2PBtn').addEventListener('click', () => this.reconnectP2P());
                document.getElementById('toggleAutoP2PBtn').addEventListener('click', () => this.toggleAutoP2P());
                document.getElementById('p2pDetailsBtn').addEventListener('click', () => this.showP2PDetails());
                
                this.elements.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendMessage();
                    }
                });
            }
            
            initWebRTC() {
                // åˆ›å»ºWebRTCå®¢æˆ·ç«¯å®ä¾‹
                this.webrtcClient = new WebRTCClient({
                    serverUrl: 'ws://127.0.0.1:9001',
                    debug: true,
                    autoInitiateP2P: false, // é»˜è®¤ä¸è‡ªåŠ¨å‘èµ·ï¼Œå¯æ‰‹åŠ¨æ§åˆ¶
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ],
                    callbacks: {
                        onConnected: () => {
                            this.updateStatus('å·²è¿æ¥åˆ°æœåŠ¡å™¨', 'connected');
                            this.setUIConnected(true);
                        },
                        onDisconnected: () => {
                            this.updateStatus('æœªè¿æ¥', 'disconnected');
                            this.updateChatMode('æœªè¿æ¥');
                            this.setUIConnected(false);
                        },
                        onUserJoined: (userId) => {
                            this.addMessage(`ç”¨æˆ· ${userId} åŠ å…¥äº†æˆ¿é—´`, 'system');
                        },
                        onUserLeft: (userId) => {
                            this.addMessage(`ç”¨æˆ· ${userId} ç¦»å¼€äº†æˆ¿é—´`, 'system');
                        },
                        onMessageReceived: (senderId, message, isP2P) => {
                            const type = isP2P ? '[P2P]' : '[è½¬å‘]';
                            this.addMessage(`${type} ${senderId}: ${message}`, 'peer');
                        },
                        onBinaryDataReceived: (senderId, data, isP2P) => {
                            const type = isP2P ? '[P2P]' : '[è½¬å‘]';
                            const size = data.byteLength || data.size || 0;
                            this.addMessage(`${type} ${senderId} å‘é€äº†æ–‡ä»¶ (${size} å­—èŠ‚)`, 'peer');
                            
                            // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œå°è¯•æ˜¾ç¤º
                            if (data instanceof Blob && data.type.startsWith('image/')) {
                                this.displayImage(data);
                            }
                        },
                        onConnectionStateChanged: (state) => {
                            this.updateChatMode(state);
                        },
                        onError: (error) => {
                            this.addMessage(`é”™è¯¯: ${error}`, 'error');
                        },
                        onDebug: (debugMessage) => {
                            this.updateDebugInfo(debugMessage);
                        }
                    }
                });
            }
            
            async connect() {
                const roomId = this.elements.roomId.value.trim();
                if (!roomId) {
                    alert('è¯·è¾“å…¥æˆ¿é—´ID');
                    return;
                }
                
                try {
                    this.addMessage('æ­£åœ¨è¿æ¥æœåŠ¡å™¨...', 'system');
                    await this.webrtcClient.connect(roomId);
                    this.addMessage('è¿æ¥æˆåŠŸï¼', 'system');
                } catch (error) {
                    this.addMessage(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            disconnect() {
                this.webrtcClient.disconnect();
                this.addMessage('å·²æ–­å¼€è¿æ¥', 'system');
            }
            
            sendMessage() {
                const message = this.elements.messageInput.value.trim();
                if (!message) return;
                
                if (this.webrtcClient.sendMessage(message)) {
                    this.addMessage(`æˆ‘: ${message}`, 'user');
                    this.elements.messageInput.value = '';
                } else {
                    this.addMessage('å‘é€å¤±è´¥', 'error');
                }
            }
            
            sendFile() {
                const file = this.elements.fileInput.files[0];
                if (!file) {
                    alert('è¯·é€‰æ‹©æ–‡ä»¶');
                    return;
                }
                
                if (this.webrtcClient.sendBinaryData(file)) {
                    this.addMessage(`æˆ‘å‘é€äº†æ–‡ä»¶: ${file.name} (${file.size} å­—èŠ‚)`, 'user');
                } else {
                    this.addMessage('æ–‡ä»¶å‘é€å¤±è´¥', 'error');
                }
            }
            
            runDebugCheck() {
                const debugInfo = this.webrtcClient.runDebugCheck();
                console.log('è°ƒè¯•ä¿¡æ¯:', debugInfo);
            }
            
            // æ–°å¢çš„P2Pæ§åˆ¶æ–¹æ³•
            async initiateP2P() {
                if (!this.webrtcClient.canInitiateP2P()) {
                    this.addMessage('âŒ å½“å‰æ— æ³•å‘èµ·P2Pè¿æ¥', 'error');
                    return;
                }
                
                this.addMessage('ğŸš€ æ‰‹åŠ¨å‘èµ·P2Pè¿æ¥...', 'system');
                const success = await this.webrtcClient.manualInitiateP2P();
                if (success) {
                    this.addMessage('âœ… P2Pè¿æ¥å‘èµ·æˆåŠŸ', 'system');
                } else {
                    this.addMessage('âŒ P2Pè¿æ¥å‘èµ·å¤±è´¥', 'error');
                }
            }
            
            async reconnectP2P() {
                this.addMessage('ğŸ”„ é‡æ–°å»ºç«‹P2Pè¿æ¥...', 'system');
                const success = await this.webrtcClient.forceReconnectP2P();
                if (success) {
                    this.addMessage('âœ… P2Pé‡è¿å‘èµ·æˆåŠŸ', 'system');
                } else {
                    this.addMessage('âŒ P2Pé‡è¿å¤±è´¥', 'error');
                }
            }
            
            toggleAutoP2P() {
                const currentState = this.webrtcClient.getConnectionState().autoInitiateP2P;
                const newState = !currentState;
                this.webrtcClient.setAutoInitiateP2P(newState);
                this.addMessage(`ğŸ”§ è‡ªåŠ¨P2Pæ¨¡å¼: ${newState ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'system');
                
                // æ›´æ–°æŒ‰é’®æ–‡å­—
                const btn = document.getElementById('toggleAutoP2PBtn');
                btn.textContent = newState ? 'ç¦ç”¨è‡ªåŠ¨P2P' : 'å¯ç”¨è‡ªåŠ¨P2P';
            }
            
            showP2PDetails() {
                const details = this.webrtcClient.getP2PConnectionDetails();
                const connectionState = this.webrtcClient.getConnectionState();
                
                const detailsText = [
                    `ğŸ“Š P2Pè¿æ¥è¯¦æƒ…:`,
                    `â€¢ æ•°æ®é€šé“: ${details.hasDataChannel ? 'å­˜åœ¨' : 'æ— '} (${details.dataChannelState || 'N/A'})`,
                    `â€¢ å¯¹ç­‰è¿æ¥: ${details.peerConnectionState || 'N/A'}`,
                    `â€¢ ICEè¿æ¥: ${details.iceConnectionState || 'N/A'}`,
                    `â€¢ ICEæ”¶é›†: ${details.iceGatheringState || 'N/A'}`,
                    `â€¢ ä¿¡ä»¤çŠ¶æ€: ${details.signalingState || 'N/A'}`,
                    `â€¢ å‘èµ·æ–¹: ${details.isInitiator ? 'æ˜¯' : 'å¦'}`,
                    `â€¢ å·²å‘é€Offer: ${details.hasSentOffer ? 'æ˜¯' : 'å¦'}`,
                    `â€¢ å·²æ”¶åˆ°Offer: ${details.hasReceivedOffer ? 'æ˜¯' : 'å¦'}`,
                    `â€¢ è‡ªåŠ¨P2P: ${connectionState.autoInitiateP2P ? 'å¯ç”¨' : 'ç¦ç”¨'}`,
                    `â€¢ å¯å‘èµ·P2P: ${connectionState.canInitiateP2P ? 'æ˜¯' : 'å¦'}`
                ].join('\n');
                
                this.addMessage(detailsText.replace(/\n/g, '<br>'), 'system');
                console.log('P2Pè¯¦æƒ…:', details, connectionState);
            }
            
            addMessage(text, type) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                messageDiv.innerHTML = `<small>[${timestamp}]</small> ${text}`;
                
                // è®¾ç½®ä¸åŒç±»å‹æ¶ˆæ¯çš„æ ·å¼
                switch (type) {
                    case 'system':
                        messageDiv.style.color = '#1565c0';
                        messageDiv.style.background = '#e3f2fd';
                        break;
                    case 'user':
                        messageDiv.style.color = '#2e7d32';
                        messageDiv.style.background = '#e8f5e8';
                        messageDiv.style.textAlign = 'right';
                        break;
                    case 'peer':
                        messageDiv.style.color = '#ef6c00';
                        messageDiv.style.background = '#fff3e0';
                        break;
                    case 'error':
                        messageDiv.style.color = '#d32f2f';
                        messageDiv.style.background = '#ffebee';
                        break;
                }
                
                messageDiv.style.margin = '3px 0';
                messageDiv.style.padding = '3px 8px';
                messageDiv.style.borderRadius = '3px';
                messageDiv.style.fontSize = '12px';
                
                this.elements.messages.appendChild(messageDiv);
                this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
            }
            
            updateStatus(text, className) {
                this.elements.status.textContent = `çŠ¶æ€: ${text}`;
                this.elements.status.className = `status ${className}`;
            }
            
            updateChatMode(mode) {
                this.elements.chatMode.textContent = `æ¨¡å¼: ${mode}`;
            }
            
            updateDebugInfo(message) {
                const debugLog = this.webrtcClient.getDebugLog(20);
                this.elements.debugInfo.innerHTML = debugLog.join('<br>');
                this.elements.debugInfo.scrollTop = this.elements.debugInfo.scrollHeight;
            }
            
            setUIConnected(connected) {
                this.elements.disconnectBtn.disabled = !connected;
                this.elements.messageInput.disabled = !connected;
                this.elements.sendBtn.disabled = !connected;
                this.elements.debugBtn.disabled = !connected;
                this.elements.fileInput.disabled = !connected;
                this.elements.sendFileBtn.disabled = !connected;
                this.elements.connectBtn.disabled = connected;
                this.elements.roomId.disabled = connected;
                
                // æ–°å¢çš„P2Pæ§åˆ¶æŒ‰é’®
                document.getElementById('initiateP2PBtn').disabled = !connected;
                document.getElementById('reconnectP2PBtn').disabled = !connected;
                document.getElementById('toggleAutoP2PBtn').disabled = !connected;
                document.getElementById('p2pDetailsBtn').disabled = !connected;
                
                // åˆå§‹åŒ–è‡ªåŠ¨P2PæŒ‰é’®æ–‡å­—
                if (connected && this.webrtcClient) {
                    const autoP2P = this.webrtcClient.getConnectionState().autoInitiateP2P;
                    document.getElementById('toggleAutoP2PBtn').textContent = autoP2P ? 'ç¦ç”¨è‡ªåŠ¨P2P' : 'å¯ç”¨è‡ªåŠ¨P2P';
                }
            }
            
            displayImage(imageBlob) {
                const img = document.createElement('img');
                img.src = URL.createObjectURL(imageBlob);
                img.style.maxWidth = '200px';
                img.style.maxHeight = '200px';
                img.style.border = '1px solid #ddd';
                img.style.borderRadius = '4px';
                img.style.margin = '5px 0';
                
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message peer';
                messageDiv.appendChild(img);
                
                this.elements.messages.appendChild(messageDiv);
                this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
            }
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new WebRTCDemo();
        });
    </script>
</body>
</html>
